unit TestuNextRow;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, System.SysUtils, System.Generics.Collections,
  System.Generics.Defaults, System.Types, System.Classes, uCSVUpdater;

type
  // Test methods for class TCSVUpdater

  TTestNextRow = class(TTestCase)
  strict private
    FStringStream : TStringStream;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure A_Null_Stream_Returns_Empty;
    procedure An_Empty_Row_Returns_Empty;
    procedure Correct_Row_Returns_After_Empty_Field;
    procedure A_Simple_Row_returns_correct_Value;
    procedure Multiple_Rows_Iteratively_Returns_Correct_Values;
    procedure Multiple_Rows_Iteratively_Returns_Correct_From_Large_FileStream;
    procedure A_Row_with_One_Complex_Field_returns_correct_Value;
    procedure A_Row_With_Two_Complex_Fields_returns_correct_Value;
    procedure A_Row_with_Multiple_CR_In_One_Field_Returns_Correct_Value;
  end;

implementation
   uses GlenKleidon.CSVUtils;


{ TTestNextRow }

procedure TTestNextRow.A_Null_Stream_Returns_Empty;
var lExpected, lResult : string;
begin
   lResult :=  nextRow(nil,#13#10, '"');
   lExpected := '';
   check(lExpected = lResult,
                  'Expected :"'+lExpected+'"'#13#10 +
                  'Actual   :"'+lResult  +'"');
end;


procedure TTestNextRow.An_Empty_Row_Returns_Empty;
var lExpected, lResult : string;
begin
   self.FStringStream.WriteString(#13#10+'Row2Field1,Row2Field2');
   self.FStringStream.Position := 0;
   lResult :=  nextRow(Self.FStringStream,#13#10, '"');
   lExpected := '';
   check(lExpected = lResult,
                  'Expected :"'+lExpected+'"'#13#10 +
                  'Actual   :"'+lResult  +'"');

end;

procedure TTestNextRow.A_Row_with_Multiple_CR_In_One_Field_Returns_Correct_Value;
begin
   raise Exception.Create('Not Implemented');

end;

procedure TTestNextRow.A_Row_with_One_Complex_Field_returns_correct_Value;
begin

   raise Exception.Create('Not Implemented');
end;

procedure TTestNextRow.A_Row_With_Two_Complex_Fields_returns_correct_Value;
begin

   raise Exception.Create('Not Implemented');
end;

procedure TTestNextRow.Correct_Row_Returns_After_Empty_Field;
var lExpected, lResult : string;
begin
   self.FStringStream.WriteString(#13#10+'Row2Field1,Row2Field2');
   self.FStringStream.Position := 0;
   //Ignore First Row.
   nextRow(Self.FStringStream,#13#10, '"');
   //Return Second Row
   lResult :=  nextRow(Self.FStringStream,#13#10, '"');
   lExpected := 'Row2Field1,Row2Field2';
   check(lExpected = lResult,
                  'Expected :"'+lExpected+'"'#13#10 +
                  'Actual   :"'+lResult  +'"');
end;

procedure TTestNextRow.A_Simple_Row_returns_correct_Value;
var lExpected, lResult : string;
begin
   self.FStringStream.WriteString('Row1Field1,Row1Field2'#13#10+'Row2Field1,Row2Field2');
   self.FStringStream.Position := 0;
   lResult :=  nextRow(Self.FStringStream,#13#10, '"');
   lExpected := 'Row1Field1,Row1Field2';
   check(lExpected = lResult,
                  'Expected :"'+lExpected+'"'#13#10 +
                  'Actual   :"'+lResult  +'"');
end;

procedure TTestNextRow.Multiple_Rows_Iteratively_Returns_Correct_Values;
var lExpected, lResult : string;
begin
   self.FStringStream.WriteString('Row1Field1,Row1Field2'#13#10+'Row2Field1,Row2Field2');
   self.FStringStream.Position := 0;
   //First Row.
   lResult :=  nextRow(Self.FStringStream,#13#10, '"');
   //Return Second Row
   lExpected := 'Row1Field1,Row1Field2';
   check(lExpected = lResult,
                  'ROW1 Expected :"'+lExpected+'"'#13#10 +
                  'ROW1 Actual   :"'+lResult  +'"');
   lResult :=  nextRow(Self.FStringStream,#13#10, '"');
   lExpected := 'Row2Field1,Row2Field2';
   check(lExpected = lResult,
                  'ROW2 Expected :"'+lExpected+'"'#13#10 +
                  'ROW2 Actual   :"'+lResult  +'"');

end;

procedure TTestNextRow.Multiple_Rows_Iteratively_Returns_Correct_From_Large_FileStream;
var lFileStream : TFileStream;
    lExpected, lResult: string;
    c: integer;
begin
   lFilestream := TFileStream.Create(expandFIleName('.\data\lots-of-fun-stuff.csv'),fmOpenRead);
   try
   lFilestream.Position := 0;
   c := 0;
   //skip over header;
   lResult := nextRow(lFilestream,#13#10, '"');
   while lResult<>'' do
   begin
     inc(c);
     nextRow(lFilestream,#13#10, '"');
     nextRow(lFilestream,#13#10, '"');
     lResult :=  nextRow(lFilestream,#13#10, '"');
     lExpected := '23,2013-1-9,"Halo Reach","Game","A Prequel to the original and famous Halo series"';
     check(lExpected = lResult,
                  'Row '+ c.ToString + 'Expected :"'+lExpected+'"'#13#10 +
                  'Row '+ c.ToString + 'Actual   :"'+lResult  +'"');
   end;
   finally
      freeandnil(lFilestream);
   end;
end;


procedure TTestNextRow.SetUp;
begin
  inherited;
  self.FStringStream := TStringStream.Create('');
end;

procedure TTestNextRow.TearDown;
begin
  inherited;
  freeAndNil(self.FStringStream);
end;


initialization
  // Register any test cases with the test runner
  RegisterTest(TTestNextRow.Suite);
end.
